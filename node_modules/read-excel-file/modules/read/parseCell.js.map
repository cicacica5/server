{"version":3,"sources":["../../source/read/parseCell.js"],"names":["parseCellValue","parseCellCoordinates","getCellValue","getCellInlineStringValue","parseCell","node","sheet","xml","values","styles","properties","options","coords","getAttribute","valueElement","value","textContent","type","hasAttribute","row","column","getInlineStringValue","getStyleId"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AAEA,SACEC,oBADF,QAEO,eAFP;AAIA,SACEC,YADF,EAEEC,wBAFF,QAGO,aAHP,C,CAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,KAAzB,EAAgCC,GAAhC,EAAqCC,MAArC,EAA6CC,MAA7C,EAAqDC,UAArD,EAAiEC,OAAjE,EAA0E;AACvF,MAAMC,MAAM,GAAGX,oBAAoB,CAACI,IAAI,CAACQ,YAAL,CAAkB,GAAlB,CAAD,CAAnC;AAEA,MAAMC,YAAY,GAAGZ,YAAY,CAACI,KAAD,EAAQD,IAAR,CAAjC,CAHuF,CAKvF;AACA;AACA;;AACA,MAAIU,KAAK,GAAGD,YAAY,IAAIA,YAAY,CAACE,WAAzC;AAEA,MAAIC,IAAJ;;AACA,MAAIZ,IAAI,CAACa,YAAL,CAAkB,GAAlB,CAAJ,EAA4B;AAC1BD,IAAAA,IAAI,GAAGZ,IAAI,CAACQ,YAAL,CAAkB,GAAlB,CAAP;AACD;;AAED,SAAO;AACLM,IAAAA,GAAG,EAAEP,MAAM,CAAC,CAAD,CADN;AAELQ,IAAAA,MAAM,EAAER,MAAM,CAAC,CAAD,CAFT;AAGLG,IAAAA,KAAK,EAAEf,cAAc,CAACe,KAAD,EAAQE,IAAR,EAAc;AACjCI,MAAAA,oBAAoB,EAAE;AAAA,eAAMlB,wBAAwB,CAACG,KAAD,EAAQD,IAAR,CAA9B;AAAA,OADW;AAEjCiB,MAAAA,UAAU,EAAE;AAAA,eAAMjB,IAAI,CAACQ,YAAL,CAAkB,GAAlB,CAAN;AAAA,OAFqB;AAGjCJ,MAAAA,MAAM,EAANA,MAHiC;AAIjCD,MAAAA,MAAM,EAANA,MAJiC;AAKjCE,MAAAA,UAAU,EAAVA,UALiC;AAMjCC,MAAAA,OAAO,EAAPA;AANiC,KAAd;AAHhB,GAAP;AAYD","sourcesContent":["import parseCellValue from './parseCellValue'\r\n\r\nimport {\r\n  parseCellCoordinates\r\n} from './coordinates'\r\n\r\nimport {\r\n  getCellValue,\r\n  getCellInlineStringValue\r\n} from '../xml/xlsx'\r\n\r\n// Example of a `<c/>`ell element:\r\n//\r\n// <c>\r\n//    <f>string</f> — formula.\r\n//    <v>string</v> — formula pre-computed value.\r\n//    <is>\r\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\r\n//       <r>\r\n//          <rPr>\r\n//            ...\r\n//          </rPr>\r\n//          <t>string</t>\r\n//       </r>\r\n//       <rPh sb=\"1\" eb=\"1\">\r\n//          <t>string</t>\r\n//       </rPh>\r\n//       <phoneticPr fontId=\"1\"/>\r\n//    </is>\r\n//    <extLst>\r\n//       <ext>\r\n//          <!--any element-->\r\n//       </ext>\r\n//    </extLst>\r\n// </c>\r\n//\r\nexport default function parseCell(node, sheet, xml, values, styles, properties, options) {\r\n  const coords = parseCellCoordinates(node.getAttribute('r'))\r\n\r\n  const valueElement = getCellValue(sheet, node)\r\n\r\n  // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\r\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\r\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\r\n  let value = valueElement && valueElement.textContent\r\n\r\n  let type\r\n  if (node.hasAttribute('t')) {\r\n    type = node.getAttribute('t')\r\n  }\r\n\r\n  return {\r\n    row: coords[0],\r\n    column: coords[1],\r\n    value: parseCellValue(value, type, {\r\n      getInlineStringValue: () => getCellInlineStringValue(sheet, node),\r\n      getStyleId: () => node.getAttribute('s'),\r\n      styles,\r\n      values,\r\n      properties,\r\n      options\r\n    })\r\n  }\r\n}"],"file":"parseCell.js"}