{"version":3,"sources":["../../source/read/coordinates.js"],"names":["LETTERS","calculateDimensions","cells","comparator","a","b","allRows","map","cell","row","sort","allCols","column","minRow","maxRow","length","minCol","maxCol","columnLettersToNumber","columnLetters","n","i","indexOf","parseCellCoordinates","coords","split","parseInt","trim"],"mappings":"AAAA;AACA,IAAMA,OAAO,GAAG,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,EAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,EAAmC,GAAnC,EAAwC,GAAxC,EAA6C,GAA7C,EAAkD,GAAlD,EAAuD,GAAvD,EAA4D,GAA5D,EAAiE,GAAjE,EAAsE,GAAtE,EAA2E,GAA3E,EAAgF,GAAhF,EAAqF,GAArF,EAA0F,GAA1F,EAA+F,GAA/F,EAAoG,GAApG,EAAyG,GAAzG,EAA8G,GAA9G,EAAmH,GAAnH,EAAwH,GAAxH,EAA6H,GAA7H,EAAkI,GAAlI,CAAhB;AAEA,OAAO,SAASC,mBAAT,CAA8BC,KAA9B,EAAqC;AAC1C,MAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUD,CAAC,GAAGC,CAAd;AAAA,GAAnB;;AACA,MAAMC,OAAO,GAAGJ,KAAK,CAACK,GAAN,CAAU,UAAAC,IAAI;AAAA,WAAIA,IAAI,CAACC,GAAT;AAAA,GAAd,EAA4BC,IAA5B,CAAiCP,UAAjC,CAAhB;AACA,MAAMQ,OAAO,GAAGT,KAAK,CAACK,GAAN,CAAU,UAAAC,IAAI;AAAA,WAAIA,IAAI,CAACI,MAAT;AAAA,GAAd,EAA+BF,IAA/B,CAAoCP,UAApC,CAAhB;AACA,MAAMU,MAAM,GAAGP,OAAO,CAAC,CAAD,CAAtB;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAACA,OAAO,CAACS,MAAR,GAAiB,CAAlB,CAAtB;AACA,MAAMC,MAAM,GAAGL,OAAO,CAAC,CAAD,CAAtB;AACA,MAAMM,MAAM,GAAGN,OAAO,CAACA,OAAO,CAACI,MAAR,GAAiB,CAAlB,CAAtB;AAEA,SAAO,CACL;AAAEN,IAAAA,GAAG,EAAEI,MAAP;AAAeD,IAAAA,MAAM,EAAEI;AAAvB,GADK,EAEL;AAAEP,IAAAA,GAAG,EAAEK,MAAP;AAAeF,IAAAA,MAAM,EAAEK;AAAvB,GAFK,CAAP;AAID,C,CAED;AACA;;AACA,SAASC,qBAAT,CAA+BC,aAA/B,EAA8C;AAC5C;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGF,aAAa,CAACJ,MAAzB,EAAiC;AAC/BK,IAAAA,CAAC,IAAI,EAAL;AACAA,IAAAA,CAAC,IAAIpB,OAAO,CAACsB,OAAR,CAAgBH,aAAa,CAACE,CAAD,CAA7B,CAAL;AACAA,IAAAA,CAAC;AACF;;AACD,SAAOD,CAAP;AACD;;AAED,OAAO,SAASG,oBAAT,CAA8BC,MAA9B,EAAsC;AAC3C;AACAA,EAAAA,MAAM,GAAGA,MAAM,CAACC,KAAP,CAAa,OAAb,CAAT;AACA,SAAO,CACL;AACAC,EAAAA,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,CAFH,EAGL;AACAN,EAAAA,qBAAqB,CAACM,MAAM,CAAC,CAAD,CAAN,CAAUG,IAAV,EAAD,CAJhB,CAAP;AAMD","sourcesContent":["// Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\r\nconst LETTERS = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\r\n\r\nexport function calculateDimensions (cells) {\r\n  const comparator = (a, b) => a - b\r\n  const allRows = cells.map(cell => cell.row).sort(comparator)\r\n  const allCols = cells.map(cell => cell.column).sort(comparator)\r\n  const minRow = allRows[0]\r\n  const maxRow = allRows[allRows.length - 1]\r\n  const minCol = allCols[0]\r\n  const maxCol = allCols[allCols.length - 1]\r\n\r\n  return [\r\n    { row: minRow, column: minCol },\r\n    { row: maxRow, column: maxCol }\r\n  ]\r\n}\r\n\r\n// Converts a letter coordinate to a digit coordinate.\r\n// Examples: \"A\" -> 1, \"B\" -> 2, \"Z\" -> 26, \"AA\" -> 27, etc.\r\nfunction columnLettersToNumber(columnLetters) {\r\n  // `for ... of ...` would require Babel polyfill for iterating a string.\r\n  let n = 0\r\n  let i = 0\r\n  while (i < columnLetters.length) {\r\n    n *= 26\r\n    n += LETTERS.indexOf(columnLetters[i])\r\n    i++\r\n  }\r\n  return n\r\n}\r\n\r\nexport function parseCellCoordinates(coords) {\r\n  // Coordinate examples: \"AA2091\", \"R988\", \"B1\".\r\n  coords = coords.split(/(\\d+)/)\r\n  return [\r\n    // Row.\r\n    parseInt(coords[1]),\r\n    // Column.\r\n    columnLettersToNumber(coords[0].trim())\r\n  ]\r\n}"],"file":"coordinates.js"}